# Git Fundamentals Training Program

## Prerequisites

- VS Code installed and configured
- Basic familiarity with VS Code interface

## Exercise 1: Installing and Verifying Git

### Objective
Check if Git is installed on your system and verify the version using VS Code's integrated terminal.

### Step 1: Open VS Code Terminal

1. Open VS Code
2. Use one of these methods to open the integrated terminal:
   - **Keyboard shortcut:** `Ctrl + ` (backtick) on Windows/Linux or `Cmd + ` on Mac
   - **Menu:** Go to `Terminal` → `New Terminal`
   - **Command Palette:** Press `Ctrl+Shift+P` (or `Cmd+Shift+P` on Mac), type "Terminal: Create New Terminal"

### Step 2: Check Git Version

In the VS Code terminal, run the following command:

```bash
git --version
```

**Expected output:**
```
git version 2.27.0 (or newer)
```

### Step 3: Install/Update Git (if needed)

If Git is not installed or you have an older version:

1. Go to [git-scm.com/downloads](https://git-scm.com/downloads)
2. Download the latest version for your operating system
3. Follow the installation instructions
4. **Important for Windows users:** During installation, select "Git Bash" as your terminal
5. Restart VS Code and open a new terminal
6. Run `git --version` again to verify

### Exercise Complete ✅
You should now have Git installed and accessible from VS Code's terminal.

---

## Exercise 2: Configuring Git

### Objective
Set up your Git identity and preferences for the first time.

### Step 1: Check Current Configuration

First, let's see what Git configuration already exists:

```bash
git config --global --list
```

This shows all current global settings. You might see some existing configuration or get no output if this is your first time using Git.

### Step 2: Configure Your Identity

In the VS Code terminal, run these commands (replace with your actual name and email):

```bash
git config --global user.name "Your Full Name"
```

```bash
git config --global user.email "your.email@example.com"
```

### Step 3: Set VS Code as Default Editor

Configure Git to use VS Code as your default editor:

```bash
git config --global core.editor "code --wait"
```

### Step 4: Configure Line Endings

**For Windows users:**
```bash
git config --global core.autocrlf true
```

**For Mac/Linux users:**
```bash
git config --global core.autocrlf input
```

**Understanding Line Endings Configuration:**

The command `git config --global core.autocrlf input` configures how Git handles line endings on Mac/Linux systems.

**What it does:**

- **`autocrlf`** stands for "automatic carriage return line feed"
- **`input`** means Git will:
  - **When checking OUT code**: Leave line endings as-is (LF only, which Mac/Linux expect)
  - **When checking IN code**: Convert any CRLF (Windows-style) line endings to LF (Unix-style)

**Why this matters:**

Different operating systems use different characters to mark the end of a line:
- **Windows**: Uses CRLF (Carriage Return + Line Feed: `\r\n`)
- **Mac/Linux**: Uses LF only (Line Feed: `\n`)

**The `input` setting prevents problems when:**
1. Someone accidentally introduces Windows-style line endings (CRLF) into your files
2. You're collaborating with Windows users - Git will normalize line endings when committing
3. You checkout code that may have mixed line endings

**Example scenario:**
- You're on Mac, collaborating with a Windows user
- Windows user commits files with CRLF line endings
- When you checkout: Files keep their LF endings (what Mac expects)
- When you commit: Any accidental CRLF gets converted to LF
- Repository stays consistent with Unix-style line endings

This is the recommended setting for Mac/Linux users in mixed-OS teams.

### Step 5: Verify Configuration

View your global Git configuration to confirm all settings:

```bash
git config --global --list
```

**Expected output should now include:**
```
user.name=Your Full Name
user.email=your.email@example.com
core.editor=code --wait
core.autocrlf=true (or input for Mac/Linux)
```

You can also view the configuration file directly in VS Code:

```bash
git config --global -e
```

This will open your Git configuration file in VS Code. You should see:
```ini
[user]
    name = Your Full Name
    email = your.email@example.com
[core]
    editor = code --wait
    autocrlf = true  # or input for Mac/Linux
```

Close the file when you're done reviewing.

### Exercise Complete ✅
Git is now configured with your identity and VS Code as the default editor.

---

## Exercise 3: Getting Help

### Objective
Learn different ways to get help with Git commands.

### Step 1: Command Help Options

Try these different help commands in the VS Code terminal:

**Full documentation:**
```bash
git config --help
```
*This opens the full manual page*

**Quick reference:**
```bash
git config -h
```
*This shows a brief summary of options*

**General Git help:**
```bash
git --help
```

### Step 2: Understanding Help Output

Run the quick help command and identify:
- What the `-h` flag does
- How to set configuration values
- The difference between `--global`, `--system`, and `--local` levels

```bash
git config -h
```

### Exercise Complete ✅
You now know how to access Git documentation and help when needed.

---

## Exercise 4: Creating Your First Repository

### Objective
Initialize a new Git repository and understand the basic structure.

### Step 1: Create Project Directory

In the VS Code terminal, create a new directory for your project:

```bash
mkdir my-first-repo
```

```bash
cd my-first-repo
```

### Step 2: Open Directory in VS Code

Open the new directory in VS Code:

```bash
code .
```

*This opens the current directory in a new VS Code window*

Accept the prompt to trust authors.

### Step 3: Initialize Git Repository

In the VS Code terminal (in your new project), initialize a Git repository:

```bash
git init
```

**Expected output:**
```
Initialized empty Git repository in /path/to/my-first-repo/.git/
```

### Step 4: Explore the Repository Structure

List all files including hidden ones:

```bash
ls -la
```

**On Windows (if using Command Prompt):**
```cmd
dir /a
```

You should see a `.git` directory. This is where Git stores all repository information.

### Step 5: Verify Repository Status

Check the status of your repository:

```bash
git status
```

**Expected output:**
```
On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

### Exercise Complete ✅
You have successfully created your first Git repository and understand its basic structure.

---

## Exercise 5: Understanding the Git Workflow

### Objective
Learn the three-stage Git workflow: Working Directory → Staging Area → Repository.

### Step 1: Create Your First Files

In the VS Code terminal, create two simple text files:

```bash
echo "Hello World" > file1.txt
```

```bash
echo "This is file 2" > file2.txt
```

### Step 2: Check Repository Status

```bash
git status
```

**Expected output:**
```
On branch main
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file1.txt
        file2.txt
```

Notice the files are shown in red - they're untracked.

### Step 3: Stage Files (Working Directory → Staging Area)

Add files to the staging area:

```bash
git add file1.txt file2.txt
```

**Alternative - Add all files:**
```bash
git add .
```

### Step 4: Check Status After Staging

```bash
git status
```

**Expected output:**
```
On branch main
No commits yet
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   file1.txt
        new file:   file2.txt
```

Notice the files are now shown in green - they're staged.

### Step 5: Commit Changes (Staging Area → Repository)

Create your first commit:

```bash
git commit -m "Initial commit: Add file1.txt and file2.txt"
```

**Expected output:**
```
[main (root-commit) abc1234] Initial commit: Add file1.txt and file2.txt
 2 files changed, 2 insertions(+)
 create mode 100644 file1.txt
 create mode 100644 file2.txt
```

### Step 6: Verify Clean Status

```bash
git status
```

**Expected output:**
```
On branch main
nothing to commit, working tree clean
```

### Exercise Complete ✅
You have successfully completed your first Git workflow cycle and understand the three stages.

---

## Exercise 6: Modifying and Staging Changes

### Objective
Practice the workflow with file modifications and understand staging area behavior.

### Step 1: Modify an Existing File

Add content to an existing file:

```bash
echo "Additional line" >> file1.txt
```

### Step 2: Check File Content

Verify the change:

```bash
cat file1.txt
```

**Expected output:**
```
Hello World
Additional line
```

### Step 3: Check Repository Status

```bash
git status
```

**Expected output:**
```
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file1.txt
```

### Step 4: Stage the Changes

```bash
git add file1.txt
```

### Step 5: Modify the File Again After Staging

```bash
echo "Another line after staging" >> file1.txt
```

### Step 6: Check Status - Understanding the Staging Area

```bash
git status
```

**Expected output:**
```
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   file1.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file1.txt
```

**Key Learning:** The same file appears in both staged and unstaged sections!

### Step 7: Stage All Changes

```bash
git add file1.txt
```

### Step 8: Commit the Changes

```bash
git commit -m "Update file1.txt with additional content"
```

### Exercise Complete ✅
You now understand how the staging area works and can handle multiple modifications to the same file.

---

## Exercise 7: Commit Best Practices

### Objective
Learn how to write meaningful commit messages and understand commit best practices.

### Step 1: Create Multiple Changes

Make several different types of changes:

```bash
echo "Bug fix content" > bugfix.txt
echo "New feature content" > feature.txt
echo "Updated documentation" >> file2.txt
```

### Step 2: Practice Selective Staging

Stage only the bug fix:

```bash
git add bugfix.txt
```

Check status:
```bash
git status
```

### Step 3: Commit with Detailed Message

```bash
git commit -m "Fix: Resolve login validation issue

- Add proper email format validation
- Fix password length requirements
- Update error messages for better UX"
```

### Step 4: Stage and Commit Feature Separately

```bash
git add feature.txt
```

```bash
git commit -m "Add: New user profile feature

Implement basic user profile functionality with:
- Profile picture upload
- Bio text editing  
- Privacy settings"
```

### Step 5: Commit Documentation Update

```bash
git add file2.txt
```

```bash
git commit -m "Docs: Update API documentation for user endpoints"
```

### Step 6: View Commit History

```bash
git log --oneline
```

**Expected output:**
```
def5678 Docs: Update API documentation for user endpoints
abc4567 Add: New user profile feature
123abcd Fix: Resolve login validation issue
456efgh Update file1.txt with additional content
789ijkl Initial commit: Add file1.txt and file2.txt
```

### Exercise Complete ✅
You now understand commit best practices and how to write meaningful commit messages.

---

## Exercise 8: Viewing Changes and History

### Objective
Learn to inspect changes before committing and browse repository history.

### Step 1: Make Some Changes

Modify a file:

```bash
echo "This change needs review" >> file1.txt
```

### Step 2: View Unstaged Changes

See what changed in your working directory:

```bash
git diff
```

**Expected output:**
```
diff --git a/file1.txt b/file1.txt
index abcc8cc..cda09d3 100644
--- a/file1.txt
+++ b/file1.txt
@@ -1,3 +1,4 @@
 Hello World
 Additional line
 Another line after staging
+This change needs review
```

This shows the differences between working directory and staging area.

### Step 3: Stage and View Staged Changes

```bash
git add file1.txt
```

View staged changes:
```bash
git diff --staged
```

**Expected output:**
```bash
diff --git a/file1.txt b/file1.txt
index abcc8cc..cda09d3 100644
--- a/file1.txt
+++ b/file1.txt
@@ -1,3 +1,4 @@
 Hello World
 Additional line
 Another line after staging
+This change needs review
```
This shows differences between staging area and last commit.

### Step 4: Set Up VS Code as Diff Tool

Configure VS Code as your visual diff tool:

```bash
git config --global diff.tool vscode
```

```bash
git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'
```

### Step 5: Use Visual Diff Tool

```bash
git difftool --staged
```

**Expected output:**
```bash
Viewing (1/1): 'file1.txt'
Launch 'vscode' [Y/n]? 
```

This will open VS Code showing a visual comparison of your changes.

### Step 6: View Commit History

```bash
git log
```

**For concise history:**
```bash
git log --oneline
```

**For detailed history:**
```bash
git log --oneline --graph --all
```

**Expected output:**
```bash
* bf6fceb (HEAD -> main) Docs: Update API documentation for user endpoints
* a9e0a32 Add: New user profile feature
* c5d11c6 Fix: Resolve login validation issue
* d8a7fa0 Update file1.txt with additional content
* 3a0f57b Initial commit: Add file1.txt and file2.txt
```

### Step 7: View a Specific Commit

```bash
git show 3a0f57b # Show the commit with the hash 3a0f57b
```

**Expected output:**

```bash
commit 3a0f57bad24150f87a674a35f8148eb0318b8df9
Author: ShocOne <62835948+ShocOne@users.noreply.github.com>
Date:   Thu Aug 28 15:27:55 2025 +0100

    Initial commit: Add file1.txt and file2.txt

diff --git a/file1.txt b/file1.txt
new file mode 100644
index 0000000..557db03
--- /dev/null
+++ b/file1.txt
@@ -0,0 +1 @@
+Hello World
diff --git a/file2.txt b/file2.txt
new file mode 100644
index 0000000..4ab7e6d
--- /dev/null
+++ b/file2.txt
@@ -0,0 +1 @@
+This is file 2
```

This shows the commit before the latest one.

### Exercise Complete ✅
You can now inspect changes and navigate repository history effectively.

---

## Exercise 9: Undoing Changes

### Objective
Learn how to undo changes at different stages of the Git workflow.

### Step 1: Create Test Changes

```bash
echo "Mistake in working directory" > mistake.txt
echo "Wrong content" >> file1.txt
```

### Step 2: Undo Working Directory Changes

Restore file1.txt to its last committed state:

```bash
git restore file1.txt
```

Verify the change was undone:
```bash
git status
```

**Expected output:**

```bash
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   file1.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        mistake.txt
```

### Step 3: Remove Untracked Files

```bash
git clean -fd
```

**Note:** `-f` forces the operation, `-d` removes directories


**Expected output:**

```bash
Removing mistake.txt
```

### Step 4: Practice Unstaging Changes

Make and stage a change:

```bash
echo "Staged change" >> file2.txt
git add file2.txt
```

Unstage the change:
```bash
git restore --staged file2.txt
```

Check status:
```bash
git status
```

**Expected output:**

```bash
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   file1.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2.txt
```

### Step 5: Restore File from Previous Commit

Delete a file and commit:

```bash
git rm bugfix.txt
git commit -m "Remove bugfix.txt"
```

**Expected output:**

```bash
[main 5986fe8] Remove bugfix.txt
 2 files changed, 1 insertion(+), 1 deletion(-)
 delete mode 100644 bugfix.txt
```

Restore the file from the previous commit:
```bash
git restore --source=HEAD~1 bugfix.txt
```

Check status:
```bash
git status
```

**Expected output:**

```bash
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

### Exercise Complete ✅
You now know how to undo changes at any stage of the Git workflow.

---

## Exercise 10: Working with File Operations

### Objective
Learn proper Git commands for file operations (rename, move, delete).

### Step 1: Rename a File Using Git

```bash
git mv file1.txt main.txt
```

Check status:
```bash
git status
```

**Expected output:**

```bash
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        renamed:    file1.txt -> main.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt

```

Commit the rename:
```bash
git commit -m "Rename file1.txt to main.txt"
```

**Expected output:**

```bash
[main 06396c8] Rename file1.txt to main.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename file1.txt => main.txt (100%)

```

### Step 2: Move Files to Subdirectory

Create a directory and move files:

```bash
mkdir src
git mv main.txt src/
git mv feature.txt src/
```

Check status and commit:
```bash
git status
git commit -m "Move files to src directory"
```

**Expected output:**

```bash
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        renamed:    feature.txt -> src/feature.txt
        renamed:    main.txt -> src/main.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt

[main 8ca65c4] Move files to src directory
 2 files changed, 0 insertions(+), 0 deletions(-)
 rename feature.txt => src/feature.txt (100%)
 rename main.txt => src/main.txt (100%)

```

### Step 3: Remove Files Properly

```bash
git rm file2.txt -f
```

Check status:
```bash
git status
```

**Expected output:**

```bash
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    file2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt

```

Commit the deletion:
```bash
git commit -m "Remove file2.txt - no longer needed"
```

**Expected output:**

```bash
[main 0b63517] Remove file2.txt - no longer needed
 1 file changed, 2 deletions(-)
 delete mode 100644 file2.txt

```

### Exercise Complete ✅
You can now properly handle file operations in Git.

---

## Exercise 11: Ignoring Files

### Objective
Learn to ignore files that shouldn't be tracked by Git.

### Step 1: Create Files to Ignore

```bash
mkdir logs
echo "Debug log entry" > logs/app.log
echo "Compiled binary" > app.exe
```

### Step 2: Check Status

```bash
git status
```

You'll see these untracked files.

**Expected output:**

```bash
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        app.exe
        bugfix.txt
        logs/

```

### Step 3: Create .gitignore File

```bash
echo "logs/" > .gitignore
echo "*.exe" >> .gitignore
echo "*.log" >> .gitignore
```

### Step 4: Verify Ignore Rules Work

```bash
git status
```

You should only see .gitignore as untracked now.

**Expected output:**

```bash
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        bugfix.txt

nothing added to commit but untracked files present (use "git add" to track)

```

### Step 5: Commit .gitignore

```bash
git add .gitignore
git commit -m "Add .gitignore to exclude logs and executables"
```

**Expected output:**

```bash
[main fd3dfbf] Add .gitignore to exclude logs and executables
 1 file changed, 3 insertions(+)
 create mode 100644 .gitignore

```

### Step 6: Test Ignore Rules

```bash
echo "Another log" > logs/debug.log
git status
```

The new log file should not appear in the status.

**Expected output:**

```bash
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt

nothing added to commit but untracked files present (use "git add" to track)

```

### Exercise Complete ✅
You can now properly ignore files that shouldn't be tracked.

---

## Exercise 12: Skipping the Staging Area

### Objective
Learn how to commit changes directly without explicitly staging them first.

### Step 1: Make a Change

Modify an existing file:

```bash
echo "test" >> src/main.txt
```

### Step 2: Check Status

```bash
git status
```

You'll see the file is modified but not staged.

**Expected output:**

```bash
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   src/main.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt

no changes added to commit (use "git add" and/or "git commit -a")

```

### Step 3: Commit with -a Flag

Skip staging and commit directly:

```bash
git commit -am "Fix the bug that prevented users from signing up"
```

**Note:** The `-a` flag stages all modified tracked files and commits them in one step.

**Expected output:**

```bash
[main 73e81cb] Fix the bug that prevented users from signing up
 1 file changed, 1 insertion(+)

```

### Important Warning

⚠️ **Use this only when you're 100% sure your changes don't need review.** The staging area exists for a reason - to review changes before committing.

### Exercise Complete ✅
You know how to skip the staging area, but use it wisely.

---

## Exercise 13: Short Status Output

### Objective
Learn to use the concise status output format for quicker information.

### Step 1: Make Test Changes

```bash
echo "sky" >> src/main.txt
echo "sky" > file2.js
```

### Step 2: Compare Status Outputs

**Verbose status:**
```bash
git status
```

**Expected output:**

```bash
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   src/main.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        bugfix.txt
        file2.js

no changes added to commit (use "git add" and/or "git commit -a")

```

**Short status:**
```bash
git status -s
```

**Expected output:**

```bash
 M src/main.txt
?? bugfix.txt
?? file2.js

```

### Step 3: Understanding Short Status

The short status has two columns:
- **Left column:** Staging area status
- **Right column:** Working directory status

Status codes:
- `M` = Modified
- `A` = Added  
- `D` = Deleted
- `??` = Untracked
- `R` = Renamed

### Step 4: Practice with Different States

Stage one file:
```bash
git add src/main.txt
```

Check short status:
```bash
git status -s
```

You should see:
- `M ` (green M, space) = Changes staged
- `??` (red) = Untracked file

**Expected output:**

```bash
M  src/main.txt
?? bugfix.txt
?? file2.js

```

### Step 5: Modify Staged File

```bash
echo "ocean" >> src/main.txt
```

Check short status:
```bash
git status -s
```

Now you should see:
- `MM` = File has both staged and unstaged changes

**Expected output:**

```bash
MM src/main.txt
?? bugfix.txt
?? file2.js

```

### Exercise Complete ✅
You can now quickly interpret Git's short status format.

---

## Exercise 14: Viewing Staged and Unstaged Changes

### Objective
Learn to inspect exactly what changes will be committed and what changes remain in the working directory.

### Step 1: Stage All Changes

```bash
git add .
```

### Step 2: View Staged Changes

See what's going in the next commit:

```bash
git diff --staged
```

**Expected output:**

```bash
diff --git a/bugfix.txt b/bugfix.txt
new file mode 100644
index 0000000..b546221
--- /dev/null
+++ b/bugfix.txt
@@ -0,0 +1 @@
+Bug fix content
diff --git a/file2.js b/file2.js
new file mode 100644
index 0000000..f5e95e7
--- /dev/null
+++ b/file2.js
@@ -0,0 +1 @@
+sky
diff --git a/src/main.txt b/src/main.txt
index 7026656..b1f52d2 100644
--- a/src/main.txt
+++ b/src/main.txt
@@ -3,3 +3,5 @@ Additional line
 Another line after staging
 This change needs review
 test
+sky
+ocean
```


### Step 3: Understanding Diff Output

The diff output shows:
- File being compared (`a/file` vs `b/file`)
- Lines removed (prefixed with `-`, shown in red)
- Lines added (prefixed with `+`, shown in green)
- Context information (`@@` headers)

### Step 4: Make More Changes

```bash
echo "hello world" > src/main.txt
```

### Step 5: View Unstaged Changes

See what's different between working directory and staging area:

```bash
git diff
```

**Expected output:**

```bash
diff --git a/src/main.txt b/src/main.txt
index b1f52d2..3b18e51 100644
--- a/src/main.txt
+++ b/src/main.txt
@@ -1,7 +1 @@
-Hello World
-Additional line
-Another line after staging
-This change needs review
-test
-sky
-ocean
+hello world
```

### Step 6: Compare Both

**Staged changes (going in next commit):**
```bash
git diff --staged
```

**Unstaged changes (not going in next commit):**
```bash
git diff
```

**Expected output:**

```bash
diff --git a/bugfix.txt b/bugfix.txt
new file mode 100644
index 0000000..b546221
--- /dev/null
+++ b/bugfix.txt
@@ -0,0 +1 @@
+Bug fix content
diff --git a/file2.js b/file2.js
new file mode 100644
index 0000000..f5e95e7
--- /dev/null
+++ b/file2.js
@@ -0,0 +1 @@
+sky
diff --git a/src/main.txt b/src/main.txt
index 7026656..b1f52d2 100644
--- a/src/main.txt
+++ b/src/main.txt
@@ -3,3 +3,5 @@ Additional line
 Another line after staging
 This change needs review
 test
+sky
+ocean
```

### Exercise Complete ✅
You can now inspect changes at different stages before committing.

---

## Exercise 15: Visual Diff Tools

### Objective
Configure and use VS Code as a visual diff tool for easier change comparison.

### Step 1: Configure VS Code as Diff Tool

```bash
git config --global diff.tool vscode
```

```bash
git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'
```

### Step 2: Verify Configuration

```bash
git config --global -e
```

You should see in your Git config:
```ini
[diff]
    tool = vscode
[difftool "vscode"]
    cmd = code --wait --diff $LOCAL $REMOTE
```

Close the config file.

### Step 3: Use Visual Diff for Unstaged Changes

```bash
git difftool
```

This opens VS Code showing a side-by-side comparison. VS Code will show:
- **Left side:** Current staging area version
- **Right side:** Working directory version

Close VS Code when done reviewing.

### Step 4: Use Visual Diff for Staged Changes

```bash
git difftool --staged
```

This shows:
- **Left side:** Last committed version
- **Right side:** Staged version

### Exercise Complete ✅
You can now use visual tools to review changes more easily.

---

## Exercise 16: Viewing History

### Objective
Learn different ways to view and navigate your project's commit history.

### Step 1: Commit Current Changes

```bash
git add .
git commit -m "Add sky and ocean to main.txt"
```


**Expected output:**

```bash
[main f5a0198] Add sky and ocean to main.txt
 3 files changed, 3 insertions(+), 5 deletions(-)
 create mode 100644 bugfix.txt
 create mode 100644 file2.js
```

### Step 2: View Full History

```bash
git log
```

This shows:
- Commit hash (unique identifier)
- Author and date
- Commit message

Navigate with:
- `Space` = Next page
- `q` = Quit

**Expected output:**

```bash
commit f5a0198e7f2b3b64921164871d4c3574414294dd (HEAD -> main)
Author: ShocOne <62835948+ShocOne@users.noreply.github.com>
Date:   Thu Aug 28 16:01:10 2025 +0100

    Add sky and ocean to main.txt

commit 73e81cbaf424f8e7f9b2622a6b3a331245cce1ad
Author: ShocOne <62835948+ShocOne@users.noreply.github.com>
Date:   Thu Aug 28 15:54:09 2025 +0100

    Fix the bug that prevented users from signing up

commit fd3dfbfc8cececd0c5621ab6dc3de2a18761f6de
Author: ShocOne <62835948+ShocOne@users.noreply.github.com>
Date:   Thu Aug 28 15:49:10 2025 +0100

    Add .gitignore to exclude logs and executables

commit 0b63517309b75ec0ac235dbbb287be19099ee99e
Author: ShocOne <62835948+ShocOne@users.noreply.github.com>
Date:   Thu Aug 28 15:46:19 2025 +0100

    Remove file2.txt - no longer needed

commit 8ca65c4f509f18e1105ba9dc30776148b93037ac
Author: ShocOne <62835948+ShocOne@users.noreply.github.com>
Date:   Thu Aug 28 15:44:42 2025 +0100
```

### Step 3: View Concise History

```bash
git log --oneline
```

Shows shortened hash and commit message only.

**Expected output:**

```bash
f5a0198 (HEAD -> main) Add sky and ocean to main.txt
73e81cb Fix the bug that prevented users from signing up
fd3dfbf Add .gitignore to exclude logs and executables
0b63517 Remove file2.txt - no longer needed
8ca65c4 Move files to src directory
06396c8 Rename file1.txt to main.txt
5986fe8 Remove bugfix.txt
bf6fceb Docs: Update API documentation for user endpoints
a9e0a32 Add: New user profile feature
c5d11c6 Fix: Resolve login validation issue
d8a7fa0 Update file1.txt with additional content
3a0f57b Initial commit: Add file1.txt and file2.txt
```

### Step 4: Reverse History Order

```bash
git log --oneline --reverse
```

Shows oldest commits first.

```bash
3a0f57b Initial commit: Add file1.txt and file2.txt
d8a7fa0 Update file1.txt with additional content
c5d11c6 Fix: Resolve login validation issue
a9e0a32 Add: New user profile feature
bf6fceb Docs: Update API documentation for user endpoints
5986fe8 Remove bugfix.txt
06396c8 Rename file1.txt to main.txt
8ca65c4 Move files to src directory
0b63517 Remove file2.txt - no longer needed
fd3dfbf Add .gitignore to exclude logs and executables
73e81cb Fix the bug that prevented users from signing up
f5a0198 (HEAD -> main) Add sky and ocean to main.txt
```

### Step 5: View History with Graph

```bash
git log --oneline --graph --all
```

```bash
* f5a0198 (HEAD -> main) Add sky and ocean to main.txt
* 73e81cb Fix the bug that prevented users from signing up
* fd3dfbf Add .gitignore to exclude logs and executables
* 0b63517 Remove file2.txt - no longer needed
* 8ca65c4 Move files to src directory
* 06396c8 Rename file1.txt to main.txt
* 5986fe8 Remove bugfix.txt
* bf6fceb Docs: Update API documentation for user endpoints
* a9e0a32 Add: New user profile feature
* c5d11c6 Fix: Resolve login validation issue
* d8a7fa0 Update file1.txt with additional content
* 3a0f57b Initial commit: Add file1.txt and file2.txt
```

Shows branch structure (more useful with multiple branches).

### Exercise Complete ✅
You can now navigate and view your project history in different formats.

---

## Exercise 17: Viewing a Specific Commit

### Objective
Learn to inspect the contents and changes of specific commits.

### Step 1: Get Commit List

```bash
git log --oneline
```

Note the commit hashes (first 7 characters).

### Step 2: View Commit by Hash

Using a commit hash from your history:
```bash
git show abc1234
```

(Replace `abc1234` with an actual hash from your history)

### Step 3: View Commit Using HEAD References

**Last commit:**
```bash
git show HEAD
```

Use q to quit.

**Previous commit:**
```bash
git show HEAD~1
```

**Two commits ago:**
```bash
git show HEAD~2
```

### Step 4: View File from Specific Commit

View the exact version of a file from a specific commit:
```bash
git show HEAD~1:src/main.txt
```

```bash
Hello World
Additional line
Another line after staging
This change needs review
test
```

### Step 5: List All Files in a Commit

```bash
git ls-tree HEAD~1
```



This shows all files and directories in that commit with:
- Object type (blob for files, tree for directories)
- Object hash
- File name

```bash
100644 blob bb7c502dce0e24ba9761e3a2cbc1f6a7b54ce3bf    .gitignore
040000 tree 28e9c2f9dae4ce819dc0cf2028d488da2c10dd62    src
```

### Step 6: View Object Contents

Using an object hash from the ls-tree output:
```bash
git show abc1234
```

### Exercise Complete ✅
You can now inspect any commit and its contents in detail.

---

## Exercise 18: Unstaging Files

### Objective
Learn to remove changes from the staging area without losing them.

### Step 1: Make and Stage Changes

```bash
echo "changes to unstage" >> src/main.txt
echo "new file content" > file3.txt
git add .
```

### Step 2: Check Status

```bash
git status
```


**Expected output:**

```bash
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   file3.txt
        modified:   src/main.txt
```

Both files should be staged (green).

### Step 3: Unstage a Modified File

```bash
git restore --staged src/main.txt
```

### Step 4: Check Status Again

```bash
git status -s
```

**Expected output:**

```bash
A  file3.txt
M src/main.txt
```

You should see:
- `src/main.txt` back to modified (red `M`)
- `file3.txt` still staged (green `A`)

### Step 5: Unstage a New File

```bash
git restore --staged file3.txt
```

### Step 6: Verify Result

```bash
git status
```

`file3.txt` should now be untracked.

**Expected output:**

```bash
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   src/main.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file3.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

### Step 7: Understand How Restore Works

The `git restore --staged` command:
- Takes the version from the last commit
- Puts it in the staging area
- Your working directory changes remain untouched

### Exercise Complete ✅
You can now unstage changes while preserving your work.

---

## Exercise 19: Discarding Local Changes

### Objective
Learn to throw away changes in your working directory.

### Step 1: Make Unwanted Changes

```bash
echo "mistake in working directory" > mistake.txt
echo "wrong content" >> src/main.txt
```

### Step 2: Check Status

```bash
git status
```

**Expected output:**

```bash
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   src/main.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file3.txt
        mistake.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

### Step 3: Restore Tracked File

Undo changes to a tracked file:
```bash
git restore src/main.txt
```

### Step 4: Verify Tracked File Restored

```bash
git status
```

`src/main.txt` should no longer appear as modified.

```bash
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file3.txt
        mistake.txt

nothing added to commit but untracked files present (use "git add" to track)
```

### Step 5: Remove Untracked Files

Remove untracked files and directories:
```bash
git clean -fd
```

```bash
Removing file3.txt
Removing mistake.txt
```


Flags:
- `-f` = Force (required for safety)
- `-d` = Remove directories too

### Step 6: Verify Clean Working Directory

```bash
git status
```
Should show "working tree clean".

```bash
On branch main
nothing to commit, working tree clean
```

### Step 7: Understanding the Restore Command

When you run `git restore filename`:
- Git takes the version from the staging area
- Copies it to the working directory
- If file isn't staged, takes it from the last commit

### Exercise Complete ✅
You can now discard unwanted changes safely.

---

## Exercise 20: Restoring Files to Earlier Versions

### Objective
Learn to recover files from previous commits.

### Step 1: Delete a File Completely

```bash
git rm src/main.txt
```

### Step 2: Commit the Deletion

```bash
git commit -m "Delete main.txt"
```

```bash
[main 4ffcb41] Delete main.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 src/main.txt
```

### Step 3: Realize the Mistake

```bash
git status
```

The file is now gone from both working directory and staging area.

```bash
On branch main
nothing to commit, working tree clean
```

### Step 4: View History

```bash
git log --oneline
```

Find the commit where the file still existed (before the deletion).

```bash
4ffcb41 (HEAD -> main) Delete main.txt
f5a0198 Add sky and ocean to main.txt
73e81cb Fix the bug that prevented users from signing up
fd3dfbf Add .gitignore to exclude logs and executables
0b63517 Remove file2.txt - no longer needed
8ca65c4 Move files to src directory
06396c8 Rename file1.txt to main.txt
5986fe8 Remove bugfix.txt
bf6fceb Docs: Update API documentation for user endpoints
a9e0a32 Add: New user profile feature
c5d11c6 Fix: Resolve login validation issue
d8a7fa0 Update file1.txt with additional content
3a0f57b Initial commit: Add file1.txt and file2.txt
```

In this case, the commit before is 'f5a0198 Add sky and ocean to main.txt'

### Step 5: Restore File from Previous Commit

```bash
git restore --source=HEAD~1 src/main.txt
```

This command:
- `--source=HEAD~1` specifies which commit to restore from
- Takes the file from that commit
- Puts it in the working directory as untracked

### Step 6: Verify File Restored

```bash
git status
```

`src/main.txt` should appear as untracked.

```bash
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        src/main.txt

nothing added to commit but untracked files present (use "git add" to track)
```

### Step 7: Check File Contents

```bash
cat src/main.txt
```

The file should contain the content from the previous commit.

```bash
hello world
```

### Step 8: Add and Commit Restored File

```bash
git add src/main.txt
git commit -m "Restore main.txt from previous commit"
```

```bash
[main 63e4ceb] Restore main.txt from previous commit
 1 file changed, 1 insertion(+)
 create mode 100644 src/main.txt
```

### Exercise Complete ✅
You can now recover files from any point in your project's history.

---

## Summary

Congratulations! You have completed the complete Git Fundamentals training program following the video tutorial. You now know how to:

### Core Git Skills ✅
- Install and configure Git with VS Code
- Initialize repositories and understand Git's structure  
- Use the three-stage workflow (Working Directory → Staging → Repository)
- Write meaningful commit messages following best practices
- Skip the staging area when appropriate (with caution)

### Viewing and Understanding Changes ✅
- Use short status format for quick information
- View staged vs unstaged changes with `git diff`
- Configure and use visual diff tools (VS Code)
- Browse repository history with various `git log` options
- Inspect specific commits and their contents

### Managing Changes ✅
- Unstage files without losing work
- Discard unwanted local changes
- Restore files from previous commits
- Properly handle file operations (rename, move, delete)
- Ignore files using .gitignore patterns

### Advanced Recovery ✅
- Recover deleted files from history
- Understand how Git's restore command works
- Navigate commit history using HEAD references
- View file contents from any commit

## Next Steps

You now have a solid foundation in Git and are ready to:
- Learn about branching and merging
- Collaborate with others using remote repositories (GitHub)
- Explore advanced Git workflows
- Learn about rebasing and rewriting history

Keep practicing these fundamentals - they form the foundation of all Git workflows. The commands you've learned represent the daily workflow of professional developers worldwide.