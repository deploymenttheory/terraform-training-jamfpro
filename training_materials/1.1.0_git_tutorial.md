# Git Fundamentals Training Program

## Prerequisites

- VS Code installed and configured
- Basic familiarity with VS Code interface

## Exercise 1: Installing and Verifying Git

### Objective
Check if Git is installed on your system and verify the version using VS Code's integrated terminal.

### Step 1: Open VS Code Terminal

1. Open VS Code
2. Use one of these methods to open the integrated terminal:
   - **Keyboard shortcut:** `Ctrl + ` (backtick) on Windows/Linux or `Cmd + ` on Mac
   - **Menu:** Go to `Terminal` → `New Terminal`
   - **Command Palette:** Press `Ctrl+Shift+P` (or `Cmd+Shift+P` on Mac), type "Terminal: Create New Terminal"

### Step 2: Check Git Version

In the VS Code terminal, run the following command:

```bash
git --version
```

**Expected output:**
```
git version 2.27.0 (or newer)
```

### Step 3: Install/Update Git (if needed)

If Git is not installed or you have an older version:

1. Go to [git-scm.com/downloads](https://git-scm.com/downloads)
2. Download the latest version for your operating system
3. Follow the installation instructions
4. **Important for Windows users:** During installation, select "Git Bash" as your terminal
5. Restart VS Code and open a new terminal
6. Run `git --version` again to verify

### Exercise Complete ✅
You should now have Git installed and accessible from VS Code's terminal.

---

## Exercise 2: Configuring Git

### Objective
Set up your Git identity and preferences for the first time.

### Step 1: Configure Your Identity

In the VS Code terminal, run these commands (replace with your actual name and email):

```bash
git config --global user.name "Your Full Name"
```

```bash
git config --global user.email "your.email@example.com"
```

### Step 2: Set VS Code as Default Editor

Configure Git to use VS Code as your default editor:

```bash
git config --global core.editor "code --wait"
```

### Step 3: Configure Line Endings

**For Windows users:**
```bash
git config --global core.autocrlf true
```

**For Mac/Linux users:**
```bash
git config --global core.autocrlf input
```

### Step 4: Verify Configuration

View your global Git configuration:

```bash
git config --global -e
```

This will open your Git configuration file in VS Code. You should see:
```ini
[user]
    name = Your Full Name
    email = your.email@example.com
[core]
    editor = code --wait
    autocrlf = true  # or input for Mac/Linux
```

Close the file when you're done reviewing.

### Exercise Complete ✅
Git is now configured with your identity and VS Code as the default editor.

---

## Exercise 3: Getting Help

### Objective
Learn different ways to get help with Git commands.

### Step 1: Command Help Options

Try these different help commands in the VS Code terminal:

**Full documentation:**
```bash
git config --help
```
*This opens the full manual page*

**Quick reference:**
```bash
git config -h
```
*This shows a brief summary of options*

**General Git help:**
```bash
git --help
```

### Step 2: Understanding Help Output

Run the quick help command and identify:
- What the `-h` flag does
- How to set configuration values
- The difference between `--global`, `--system`, and `--local` levels

```bash
git config -h
```

### Exercise Complete ✅
You now know how to access Git documentation and help when needed.

---

## Exercise 4: Creating Your First Repository

### Objective
Initialize a new Git repository and understand the basic structure.

### Step 1: Create Project Directory

In the VS Code terminal, create a new directory for your project:

```bash
mkdir my-first-repo
```

```bash
cd my-first-repo
```

### Step 2: Open Directory in VS Code

Open the new directory in VS Code:

```bash
code .
```

*This opens the current directory in a new VS Code window*

### Step 3: Initialize Git Repository

In the VS Code terminal (in your new project), initialize a Git repository:

```bash
git init
```

**Expected output:**
```
Initialized empty Git repository in /path/to/my-first-repo/.git/
```

### Step 4: Explore the Repository Structure

List all files including hidden ones:

```bash
ls -la
```

**On Windows (if using Command Prompt):**
```cmd
dir /a
```

You should see a `.git` directory. This is where Git stores all repository information.

### Step 5: Verify Repository Status

Check the status of your repository:

```bash
git status
```

**Expected output:**
```
On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

### Exercise Complete ✅
You have successfully created your first Git repository and understand its basic structure.

---

## Exercise 5: Understanding the Git Workflow

### Objective
Learn the three-stage Git workflow: Working Directory → Staging Area → Repository.

### Step 1: Create Your First Files

In the VS Code terminal, create two simple text files:

```bash
echo "Hello World" > file1.txt
```

```bash
echo "This is file 2" > file2.txt
```

### Step 2: Check Repository Status

```bash
git status
```

**Expected output:**
```
On branch main
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file1.txt
        file2.txt
```

Notice the files are shown in red - they're untracked.

### Step 3: Stage Files (Working Directory → Staging Area)

Add files to the staging area:

```bash
git add file1.txt file2.txt
```

**Alternative - Add all files:**
```bash
git add .
```

### Step 4: Check Status After Staging

```bash
git status
```

**Expected output:**
```
On branch main
No commits yet
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   file1.txt
        new file:   file2.txt
```

Notice the files are now shown in green - they're staged.

### Step 5: Commit Changes (Staging Area → Repository)

Create your first commit:

```bash
git commit -m "Initial commit: Add file1.txt and file2.txt"
```

**Expected output:**
```
[main (root-commit) abc1234] Initial commit: Add file1.txt and file2.txt
 2 files changed, 2 insertions(+)
 create mode 100644 file1.txt
 create mode 100644 file2.txt
```

### Step 6: Verify Clean Status

```bash
git status
```

**Expected output:**
```
On branch main
nothing to commit, working tree clean
```

### Exercise Complete ✅
You have successfully completed your first Git workflow cycle and understand the three stages.

---

## Exercise 6: Modifying and Staging Changes

### Objective
Practice the workflow with file modifications and understand staging area behavior.

### Step 1: Modify an Existing File

Add content to an existing file:

```bash
echo "Additional line" >> file1.txt
```

### Step 2: Check File Content

Verify the change:

```bash
cat file1.txt
```

**Expected output:**
```
Hello World
Additional line
```

### Step 3: Check Repository Status

```bash
git status
```

**Expected output:**
```
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file1.txt
```

### Step 4: Stage the Changes

```bash
git add file1.txt
```

### Step 5: Modify the File Again After Staging

```bash
echo "Another line after staging" >> file1.txt
```

### Step 6: Check Status - Understanding the Staging Area

```bash
git status
```

**Expected output:**
```
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   file1.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   file1.txt
```

**Key Learning:** The same file appears in both staged and unstaged sections!

### Step 7: Stage All Changes

```bash
git add file1.txt
```

### Step 8: Commit the Changes

```bash
git commit -m "Update file1.txt with additional content"
```

### Exercise Complete ✅
You now understand how the staging area works and can handle multiple modifications to the same file.

---

## Exercise 7: Commit Best Practices

### Objective
Learn how to write meaningful commit messages and understand commit best practices.

### Step 1: Create Multiple Changes

Make several different types of changes:

```bash
echo "Bug fix content" > bugfix.txt
echo "New feature content" > feature.txt
echo "Updated documentation" >> file2.txt
```

### Step 2: Practice Selective Staging

Stage only the bug fix:

```bash
git add bugfix.txt
```

Check status:
```bash
git status
```

### Step 3: Commit with Detailed Message

```bash
git commit -m "Fix: Resolve login validation issue

- Add proper email format validation
- Fix password length requirements
- Update error messages for better UX"
```

### Step 4: Stage and Commit Feature Separately

```bash
git add feature.txt
```

```bash
git commit -m "Add: New user profile feature

Implement basic user profile functionality with:
- Profile picture upload
- Bio text editing  
- Privacy settings"
```

### Step 5: Commit Documentation Update

```bash
git add file2.txt
```

```bash
git commit -m "Docs: Update API documentation for user endpoints"
```

### Step 6: View Commit History

```bash
git log --oneline
```

**Expected output:**
```
def5678 Docs: Update API documentation for user endpoints
abc4567 Add: New user profile feature
123abcd Fix: Resolve login validation issue
456efgh Update file1.txt with additional content
789ijkl Initial commit: Add file1.txt and file2.txt
```

### Exercise Complete ✅
You now understand commit best practices and how to write meaningful commit messages.

---

## Exercise 8: Viewing Changes and History

### Objective
Learn to inspect changes before committing and browse repository history.

### Step 1: Make Some Changes

Modify a file:

```bash
echo "This change needs review" >> file1.txt
```

### Step 2: View Unstaged Changes

See what changed in your working directory:

```bash
git diff
```

This shows the differences between working directory and staging area.

### Step 3: Stage and View Staged Changes

```bash
git add file1.txt
```

View staged changes:
```bash
git diff --staged
```

This shows differences between staging area and last commit.

### Step 4: Set Up VS Code as Diff Tool

Configure VS Code as your visual diff tool:

```bash
git config --global diff.tool vscode
```

```bash
git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'
```

### Step 5: Use Visual Diff Tool

```bash
git difftool --staged
```

This will open VS Code showing a visual comparison of your changes.

### Step 6: View Commit History

```bash
git log
```

**For concise history:**
```bash
git log --oneline
```

**For detailed history:**
```bash
git log --oneline --graph --all
```

### Step 7: View a Specific Commit

```bash
git show HEAD~1
```

This shows the commit before the latest one.

### Exercise Complete ✅
You can now inspect changes and navigate repository history effectively.

---

## Exercise 9: Undoing Changes

### Objective
Learn how to undo changes at different stages of the Git workflow.

### Step 1: Create Test Changes

```bash
echo "Mistake in working directory" > mistake.txt
echo "Wrong content" >> file1.txt
```

### Step 2: Undo Working Directory Changes

Restore file1.txt to its last committed state:

```bash
git restore file1.txt
```

Verify the change was undone:
```bash
git status
```

### Step 3: Remove Untracked Files

```bash
git clean -fd
```

**Note:** `-f` forces the operation, `-d` removes directories

### Step 4: Practice Unstaging Changes

Make and stage a change:

```bash
echo "Staged change" >> file2.txt
git add file2.txt
```

Unstage the change:
```bash
git restore --staged file2.txt
```

Check status:
```bash
git status
```

### Step 5: Restore File from Previous Commit

Delete a file and commit:

```bash
git rm bugfix.txt
git commit -m "Remove bugfix.txt"
```

Restore the file from the previous commit:
```bash
git restore --source=HEAD~1 bugfix.txt
```

Check status:
```bash
git status
```

### Exercise Complete ✅
You now know how to undo changes at any stage of the Git workflow.

---

## Exercise 10: Working with File Operations

### Objective
Learn proper Git commands for file operations (rename, move, delete).

### Step 1: Rename a File Using Git

```bash
git mv file1.txt main.txt
```

Check status:
```bash
git status
```

Commit the rename:
```bash
git commit -m "Rename file1.txt to main.txt"
```

### Step 2: Move Files to Subdirectory

Create a directory and move files:

```bash
mkdir src
git mv main.txt src/
git mv feature.txt src/
```

Check status and commit:
```bash
git status
git commit -m "Move files to src directory"
```

### Step 3: Remove Files Properly

```bash
git rm file2.txt
```

Check status:
```bash
git status
```

Commit the deletion:
```bash
git commit -m "Remove file2.txt - no longer needed"
```

### Exercise Complete ✅
You can now properly handle file operations in Git.

---

## Exercise 11: Ignoring Files

### Objective
Learn to ignore files that shouldn't be tracked by Git.

### Step 1: Create Files to Ignore

```bash
mkdir logs
echo "Debug log entry" > logs/app.log
echo "Compiled binary" > app.exe
```

### Step 2: Check Status

```bash
git status
```

You'll see these untracked files.

### Step 3: Create .gitignore File

```bash
echo "logs/" > .gitignore
echo "*.exe" >> .gitignore
echo "*.log" >> .gitignore
```

### Step 4: Verify Ignore Rules Work

```bash
git status
```

You should only see .gitignore as untracked now.

### Step 5: Commit .gitignore

```bash
git add .gitignore
git commit -m "Add .gitignore to exclude logs and executables"
```

### Step 6: Test Ignore Rules

```bash
echo "Another log" > logs/debug.log
git status
```

The new log file should not appear in the status.

### Exercise Complete ✅
You can now properly ignore files that shouldn't be tracked.

---

## Exercise 12: Skipping the Staging Area

### Objective
Learn how to commit changes directly without explicitly staging them first.

### Step 1: Make a Change

Modify an existing file:

```bash
echo "test" >> src/main.txt
```

### Step 2: Check Status

```bash
git status
```

You'll see the file is modified but not staged.

### Step 3: Commit with -a Flag

Skip staging and commit directly:

```bash
git commit -am "Fix the bug that prevented users from signing up"
```

**Note:** The `-a` flag stages all modified tracked files and commits them in one step.

### Important Warning

⚠️ **Use this only when you're 100% sure your changes don't need review.** The staging area exists for a reason - to review changes before committing.

### Exercise Complete ✅
You know how to skip the staging area, but use it wisely.

---

## Exercise 13: Short Status Output

### Objective
Learn to use the concise status output format for quicker information.

### Step 1: Make Test Changes

```bash
echo "sky" >> src/main.txt
echo "sky" > file2.js
```

### Step 2: Compare Status Outputs

**Verbose status:**
```bash
git status
```

**Short status:**
```bash
git status -s
```

### Step 3: Understanding Short Status

The short status has two columns:
- **Left column:** Staging area status
- **Right column:** Working directory status

Status codes:
- `M` = Modified
- `A` = Added  
- `D` = Deleted
- `??` = Untracked
- `R` = Renamed

### Step 4: Practice with Different States

Stage one file:
```bash
git add src/main.txt
```

Check short status:
```bash
git status -s
```

You should see:
- `M ` (green M, space) = Changes staged
- `??` (red) = Untracked file

### Step 5: Modify Staged File

```bash
echo "ocean" >> src/main.txt
```

Check short status:
```bash
git status -s
```

Now you should see:
- `MM` = File has both staged and unstaged changes

### Exercise Complete ✅
You can now quickly interpret Git's short status format.

---

## Exercise 14: Viewing Staged and Unstaged Changes

### Objective
Learn to inspect exactly what changes will be committed and what changes remain in the working directory.

### Step 1: Stage All Changes

```bash
git add .
```

### Step 2: View Staged Changes

See what's going in the next commit:

```bash
git diff --staged
```

### Step 3: Understanding Diff Output

The diff output shows:
- File being compared (`a/file` vs `b/file`)
- Lines removed (prefixed with `-`, shown in red)
- Lines added (prefixed with `+`, shown in green)
- Context information (`@@` headers)

### Step 4: Make More Changes

```bash
echo "hello world" > src/main.txt
```

### Step 5: View Unstaged Changes

See what's different between working directory and staging area:

```bash
git diff
```

### Step 6: Compare Both

**Staged changes (going in next commit):**
```bash
git diff --staged
```

**Unstaged changes (not going in next commit):**
```bash
git diff
```

### Exercise Complete ✅
You can now inspect changes at different stages before committing.

---

## Exercise 15: Visual Diff Tools

### Objective
Configure and use VS Code as a visual diff tool for easier change comparison.

### Step 1: Configure VS Code as Diff Tool

```bash
git config --global diff.tool vscode
```

```bash
git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'
```

### Step 2: Verify Configuration

```bash
git config --global -e
```

You should see in your Git config:
```ini
[diff]
    tool = vscode
[difftool "vscode"]
    cmd = code --wait --diff $LOCAL $REMOTE
```

Close the config file.

### Step 3: Use Visual Diff for Unstaged Changes

```bash
git difftool
```

This opens VS Code showing a side-by-side comparison. VS Code will show:
- **Left side:** Current staging area version
- **Right side:** Working directory version

Close VS Code when done reviewing.

### Step 4: Use Visual Diff for Staged Changes

```bash
git difftool --staged
```

This shows:
- **Left side:** Last committed version
- **Right side:** Staged version

### Exercise Complete ✅
You can now use visual tools to review changes more easily.

---

## Exercise 16: Viewing History

### Objective
Learn different ways to view and navigate your project's commit history.

### Step 1: Commit Current Changes

```bash
git add .
git commit -m "Add sky and ocean to main.txt"
```

### Step 2: View Full History

```bash
git log
```

This shows:
- Commit hash (unique identifier)
- Author and date
- Commit message

Navigate with:
- `Space` = Next page
- `q` = Quit

### Step 3: View Concise History

```bash
git log --oneline
```

Shows shortened hash and commit message only.

### Step 4: Reverse History Order

```bash
git log --oneline --reverse
```

Shows oldest commits first.

### Step 5: View History with Graph

```bash
git log --oneline --graph --all
```

Shows branch structure (more useful with multiple branches).

### Exercise Complete ✅
You can now navigate and view your project history in different formats.

---

## Exercise 17: Viewing a Specific Commit

### Objective
Learn to inspect the contents and changes of specific commits.

### Step 1: Get Commit List

```bash
git log --oneline
```

Note the commit hashes (first 7 characters).

### Step 2: View Commit by Hash

Using a commit hash from your history:
```bash
git show abc1234
```

(Replace `abc1234` with an actual hash from your history)

### Step 3: View Commit Using HEAD References

**Last commit:**
```bash
git show HEAD
```

**Previous commit:**
```bash
git show HEAD~1
```

**Two commits ago:**
```bash
git show HEAD~2
```

### Step 4: View File from Specific Commit

View the exact version of a file from a specific commit:
```bash
git show HEAD~1:src/main.txt
```

### Step 5: List All Files in a Commit

```bash
git ls-tree HEAD~1
```

This shows all files and directories in that commit with:
- Object type (blob for files, tree for directories)
- Object hash
- File name

### Step 6: View Object Contents

Using an object hash from the ls-tree output:
```bash
git show abc1234
```

### Exercise Complete ✅
You can now inspect any commit and its contents in detail.

---

## Exercise 18: Unstaging Files

### Objective
Learn to remove changes from the staging area without losing them.

### Step 1: Make and Stage Changes

```bash
echo "changes to unstage" >> src/main.txt
echo "new file content" > file3.txt
git add .
```

### Step 2: Check Status

```bash
git status
```

Both files should be staged (green).

### Step 3: Unstage a Modified File

```bash
git restore --staged src/main.txt
```

### Step 4: Check Status Again

```bash
git status -s
```

You should see:
- `src/main.txt` back to modified (red `M`)
- `file3.txt` still staged (green `A`)

### Step 5: Unstage a New File

```bash
git restore --staged file3.txt
```

### Step 6: Verify Result

```bash
git status
```

`file3.txt` should now be untracked.

### Step 7: Understand How Restore Works

The `git restore --staged` command:
- Takes the version from the last commit
- Puts it in the staging area
- Your working directory changes remain untouched

### Exercise Complete ✅
You can now unstage changes while preserving your work.

---

## Exercise 19: Discarding Local Changes

### Objective
Learn to throw away changes in your working directory.

### Step 1: Make Unwanted Changes

```bash
echo "mistake in working directory" > mistake.txt
echo "wrong content" >> src/main.txt
```

### Step 2: Check Status

```bash
git status
```

### Step 3: Restore Tracked File

Undo changes to a tracked file:
```bash
git restore src/main.txt
```

### Step 4: Verify Tracked File Restored

```bash
git status
```

`src/main.txt` should no longer appear as modified.

### Step 5: Remove Untracked Files

Remove untracked files and directories:
```bash
git clean -fd
```

Flags:
- `-f` = Force (required for safety)
- `-d` = Remove directories too

### Step 6: Verify Clean Working Directory

```bash
git status
```

Should show "working tree clean".

### Step 7: Understanding the Restore Command

When you run `git restore filename`:
- Git takes the version from the staging area
- Copies it to the working directory
- If file isn't staged, takes it from the last commit

### Exercise Complete ✅
You can now discard unwanted changes safely.

---

## Exercise 20: Restoring Files to Earlier Versions

### Objective
Learn to recover files from previous commits.

### Step 1: Delete a File Completely

```bash
git rm src/main.txt
```

### Step 2: Commit the Deletion

```bash
git commit -m "Delete main.txt"
```

### Step 3: Realize the Mistake

```bash
git status
```

The file is now gone from both working directory and staging area.

### Step 4: View History

```bash
git log --oneline
```

Find the commit where the file still existed (before the deletion).

### Step 5: Restore File from Previous Commit

```bash
git restore --source=HEAD~1 src/main.txt
```

This command:
- `--source=HEAD~1` specifies which commit to restore from
- Takes the file from that commit
- Puts it in the working directory as untracked

### Step 6: Verify File Restored

```bash
git status
```

`src/main.txt` should appear as untracked.

### Step 7: Check File Contents

```bash
cat src/main.txt
```

The file should contain the content from the previous commit.

### Step 8: Add and Commit Restored File

```bash
git add src/main.txt
git commit -m "Restore main.txt from previous commit"
```

### Exercise Complete ✅
You can now recover files from any point in your project's history.

---

## Summary

Congratulations! You have completed the complete Git Fundamentals training program following the video tutorial. You now know how to:

### Core Git Skills ✅
- Install and configure Git with VS Code
- Initialize repositories and understand Git's structure  
- Use the three-stage workflow (Working Directory → Staging → Repository)
- Write meaningful commit messages following best practices
- Skip the staging area when appropriate (with caution)

### Viewing and Understanding Changes ✅
- Use short status format for quick information
- View staged vs unstaged changes with `git diff`
- Configure and use visual diff tools (VS Code)
- Browse repository history with various `git log` options
- Inspect specific commits and their contents

### Managing Changes ✅
- Unstage files without losing work
- Discard unwanted local changes
- Restore files from previous commits
- Properly handle file operations (rename, move, delete)
- Ignore files using .gitignore patterns

### Advanced Recovery ✅
- Recover deleted files from history
- Understand how Git's restore command works
- Navigate commit history using HEAD references
- View file contents from any commit

## Next Steps

You now have a solid foundation in Git and are ready to:
- Learn about branching and merging
- Collaborate with others using remote repositories (GitHub)
- Explore advanced Git workflows
- Learn about rebasing and rewriting history

Keep practicing these fundamentals - they form the foundation of all Git workflows. The commands you've learned represent the daily workflow of professional developers worldwide.